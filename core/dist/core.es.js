var t,n=Object.assign,e=new Uint8Array(16);function r(){if(!t&&!(t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}var o=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function i(t){return"string"==typeof t&&o.test(t)}for(var u,a,c=[],p=0;p<256;++p)c.push((p+256).toString(16).substr(1));function s(t,n,e){var o=(t=t||{}).random||(t.rng||r)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,n){e=e||0;for(var u=0;u<16;++u)n[e+u]=o[u];return n}return function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=(c[t[n+0]]+c[t[n+1]]+c[t[n+2]]+c[t[n+3]]+"-"+c[t[n+4]]+c[t[n+5]]+"-"+c[t[n+6]]+c[t[n+7]]+"-"+c[t[n+8]]+c[t[n+9]]+"-"+c[t[n+10]]+c[t[n+11]]+c[t[n+12]]+c[t[n+13]]+c[t[n+14]]+c[t[n+15]]).toLowerCase();if(!i(e))throw TypeError("Stringified UUID is invalid");return e}(o)}(a=u||(u={})).any="any",a.str="string",a.num="number",a.obj="object",a.vec2="vec2",a.vec3="vec3",a.rgb="rgb",a.hsl="hsl",a.vec4="vec4",a.rgba="rgba",a.mat2="mat2",a.mat3="mat3",a.mat4="mat4";const d=t=>[...Array(t).keys()];function f(t,e,r){const o=function(t,n){var e;const r=(null==n?void 0:n.inputTypes)||(null==(e=d(t.length))?void 0:e.map((t=>u.any))),o=(null==n?void 0:n.outputTypes)||[];return(...n)=>{var e,i;let u=t(...n)||[];return u.__inputs__=null==(e=d(t.length))?void 0:e.map(((t,e)=>r[e]||typeof n[e])),u.__outputs__=null==(i=d(u.length))?void 0:i.map(((t,n)=>o[n]||typeof u[n])),u}}(t,{inputTypes:(r=n({in:[],out:[]},r||{})).in.map((t=>t.type)),outputTypes:r.out.map((t=>t.type))}),i=o(...e);let a=e.map(((t,e)=>n(n({},r.in[e]),{value:t,connected:[]}))),c=i.map(((t,e)=>n(n({},r.out[e]),{value:t,connected:[]})));const p=t=>a.findIndex((n=>n.name===t));let f=new Proxy(a,(t=>({set:(n,e,r)=>{try{n[e]=r}catch(o){return!1}finally{return t(r),!0}}}))((()=>v())));const l={},m=[],y={id:s(),inputs:a,outputs:c,run:v,set:g,pipe:function(t,n=h){return l[t.id]={node:t,pipe:n},y.outputs.forEach(((n,e)=>{n.connected.find((n=>n.id===t.id&&n.port===e))||n.connected.push({id:t.id,port:e})})),t.inputs.forEach(((t,n)=>{t.connected.find((t=>t.id===y.id&&t.port===n))||t.connected.push({id:y.id,port:n})})),y.run(),t},connect:function(t,n,e){l[`${n.id}:${e}`]={node:n,pipe:(...n)=>({[e]:n[t]})};const r=y.outputs[t].connected;r.find((t=>t.id===n.id&&t.port===e))||r.push({id:n.id,port:e});const o=n.inputs[e].connected;o.find((n=>n.id===y.id&&n.port===t))||o.push({id:y.id,port:t});return y.run(),m.forEach((t=>t(y))),y},disconnect:function(t,n,e){delete l[`${n.id}:${e}`];const r=y.outputs[t].connected,o=r.findIndex((t=>t.id===n.id&&t.port===e));o>-1&&(r.splice(o,1),n.inputs[e].connected=[]);return n.reset(e),y},reset:function(t){let n=isNaN(parseInt(t))?p(t):t;g({[n]:e[n]})},subscribe:function(t){return m.push(t),m.length-1},unsubscribe:function(t){return!(t>m.length)&&(m.splice(t,1),!0)}};function v(t=a.map((t=>t.value))){const e=o(...t);return Object.assign(c,e.map(((t,e)=>n(n({},c[e]),{value:t})))),Object.values(l).forEach((({node:t,pipe:n})=>t.set(n(...e)))),m.forEach((t=>t(y))),y}function g(t){return Array.isArray(t)?Object.assign(f,t.map(((t,e)=>n(n({},a[e]),{value:t})))):"object"==typeof t?Object.entries(t).forEach((([t,e])=>{let r=isNaN(parseInt(t))?p(t):t;if(!(r>-1))throw new Error(`Unrecognized input name '${t}'.`);f[r]=n(n({},a[r]),{value:e})})):"function"==typeof t?Object.assign(f,t(...a.map((t=>t.value))).map(((t,e)=>n(n({},a[e]),{value:t})))):Object.assign(f,[t].map(((t,e)=>n(n({},a[e]),{value:t})))),m.forEach((t=>t(y))),y}const h=(...t)=>[...t];return y}export{u as DT,f as create};
