var t,n=Object.assign,e=new Uint8Array(16);function r(){if(!t&&!(t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}var o=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function u(t){return"string"==typeof t&&o.test(t)}for(var i,a,c=[],s=0;s<256;++s)c.push((s+256).toString(16).substr(1));function p(t,n,e){var o=(t=t||{}).random||(t.rng||r)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,n){e=e||0;for(var i=0;i<16;++i)n[e+i]=o[i];return n}return function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=(c[t[n+0]]+c[t[n+1]]+c[t[n+2]]+c[t[n+3]]+"-"+c[t[n+4]]+c[t[n+5]]+"-"+c[t[n+6]]+c[t[n+7]]+"-"+c[t[n+8]]+c[t[n+9]]+"-"+c[t[n+10]]+c[t[n+11]]+c[t[n+12]]+c[t[n+13]]+c[t[n+14]]+c[t[n+15]]).toLowerCase();if(!u(e))throw TypeError("Stringified UUID is invalid");return e}(o)}(a=i||(i={})).any="any",a.str="string",a.num="number",a.obj="object",a.vec2="vec2",a.vec3="vec3",a.rgb="rgb",a.hsl="hsl",a.vec4="vec4",a.rgba="rgba",a.mat2="mat2",a.mat3="mat3",a.mat4="mat4";const d=t=>[...Array(t).keys()];function f(t,e,r){const o=function(t,n){var e;const r=(null==n?void 0:n.inputTypes)||(null==(e=d(t.length))?void 0:e.map((t=>i.any))),o=(null==n?void 0:n.outputTypes)||[];return(...n)=>{var e,u;let i=t(...n)||[];return i.__inputs__=null==(e=d(t.length))?void 0:e.map(((t,e)=>r[e]||typeof n[e])),i.__outputs__=null==(u=d(i.length))?void 0:u.map(((t,n)=>o[n]||typeof i[n])),i}}(t,{inputTypes:(r=n({in:[],out:[]},r||{})).in.map((t=>t.type)),outputTypes:r.out.map((t=>t.type))}),u=o(...e);let a=e.map(((t,e)=>n(n({},r.in[e]),{value:t,connected:[]}))),c=u.map(((t,e)=>n(n({},r.out[e]),{value:t,connected:[]})));let s=new Proxy(a,(t=>({set:(n,e,r)=>{try{n[e]=r}catch(o){return!1}finally{return t(r),!0}}}))((()=>y())));const f={},l=[],m={id:p(),inputs:a,outputs:c,run:y,set:function(t){Array.isArray(t)?Object.assign(s,t.map(((t,e)=>n(n({},a[e]),{value:t})))):"object"==typeof t?Object.entries(t).forEach((([t,e])=>{let r=isNaN(parseInt(t))?(t=>a.findIndex((n=>n.name===t)))(t):t;if(!(r>-1))throw new Error(`Unrecognized input name '${t}'.`);s[r]=n(n({},a[r]),{value:e})})):"function"==typeof t?Object.assign(s,t(...a.map((t=>t.value))).map(((t,e)=>n(n({},a[e]),{value:t})))):Object.assign(s,[t].map(((t,e)=>n(n({},a[e]),{value:t}))));return l.forEach((t=>t(m))),m},pipe:function(t,n=v){return f[t.id]={node:t,pipe:n},m.outputs.forEach(((n,e)=>n.connected.push({id:t.id,idx:e}))),t.inputs.forEach(((t,n)=>t.connected.push({id:m.id,idx:n}))),m.run(),t},connect:function(t,n,e){return f[n.id]={node:n,pipe:(...n)=>({[e]:n[t]})},m.outputs[t].connected.push({id:n.id,idx:e}),n.inputs[e].connected.push({id:m.id,idx:t}),m.run(),l.forEach((t=>t(m))),m},disconnect:function(t,n,e){const r=m.outputs[t].connected.findIndex((({id:t,idx:r})=>t===n.id&&r===e));return m.outputs[t].connected.splice(r,1),n.inputs[e].connected=[],m},subscribe:function(t){return l.push(t),l.length-1},unsubscribe:function(t){return!(t>l.length)&&(l.splice(t,1),!0)}};function y(t=a.map((t=>t.value))){const e=o(...t);return Object.assign(c,e.map(((t,e)=>n(n({},c[e]),{value:t})))),Object.values(f).forEach((({node:t,pipe:n})=>t.set(n(...e)))),l.forEach((t=>t(m))),m}const v=(...t)=>[...t];return m}export{i as DT,f as create};
