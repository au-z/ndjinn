var __assign=Object.assign;!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((n="undefined"!=typeof globalThis?globalThis:n||self).core={})}(this,(function(n){"use strict";var t,e=new Uint8Array(16);function o(){if(!t&&!(t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}var i=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function s(n){return"string"==typeof n&&i.test(n)}for(var r,u=[],a=0;a<256;++a)u.push((a+256).toString(16).substr(1));function c(n,t,e){var i=(n=n||{}).random||(n.rng||o)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,t){e=e||0;for(var r=0;r<16;++r)t[e+r]=i[r];return t}return function(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=(u[n[t+0]]+u[n[t+1]]+u[n[t+2]]+u[n[t+3]]+"-"+u[n[t+4]]+u[n[t+5]]+"-"+u[n[t+6]]+u[n[t+7]]+"-"+u[n[t+8]]+u[n[t+9]]+"-"+u[n[t+10]]+u[n[t+11]]+u[n[t+12]]+u[n[t+13]]+u[n[t+14]]+u[n[t+15]]).toLowerCase();if(!s(e))throw TypeError("Stringified UUID is invalid");return e}(i)}n.DT=void 0,(r=n.DT||(n.DT={})).any="any",r.str="string",r.num="number",r.obj="object",r.vec2="vec2",r.vec3="vec3",r.rgb="rgb",r.hsl="hsl",r.vec4="vec4",r.rgba="rgba",r.mat2="mat2",r.mat3="mat3",r.mat4="mat4";const p=n=>[...Array(n).keys()];n.create=function(t,e,o){const i=function(t,e){var o;const i=(null==e?void 0:e.inputTypes)||(null==(o=p(t.length))?void 0:o.map((t=>n.DT.any))),s=(null==e?void 0:e.outputTypes)||[];return(...n)=>{var e,o;let r=t(...n)||[];return r.__inputs__=null==(e=p(t.length))?void 0:e.map(((t,e)=>i[e]||typeof n[e])),r.__outputs__=null==(o=p(r.length))?void 0:o.map(((n,t)=>s[t]||typeof r[t])),r}}(t,{inputTypes:(o=__assign({in:[],out:[]},o||{})).in.map((n=>n.type)),outputTypes:o.out.map((n=>n.type))}),s=i(...e);let r=e.map(((n,t)=>__assign(__assign({},o.in[t]),{value:n,connected:[]}))),u=s.map(((n,t)=>__assign(__assign({},o.out[t]),{value:n,connected:[]}))),a=new Proxy(r,(n=>({set:(t,e,o)=>{try{t[e]=o}catch(i){return!1}finally{return n(o),!0}}}))((()=>g())));const d={},f=[],l={id:c(),inputs:r,outputs:u,run:g,set:function(n){Array.isArray(n)?Object.assign(a,n.map(((n,t)=>__assign(__assign({},r[t]),{value:n})))):"object"==typeof n?Object.entries(n).forEach((([n,t])=>{let e=isNaN(parseInt(n))?(n=>r.findIndex((t=>t.name===n)))(n):n;if(!(e>-1))throw new Error(`Unrecognized input name '${n}'.`);a[e]=__assign(__assign({},r[e]),{value:t})})):"function"==typeof n?Object.assign(a,n(...r.map((n=>n.value))).map(((n,t)=>__assign(__assign({},r[t]),{value:n})))):Object.assign(a,[n].map(((n,t)=>__assign(__assign({},r[t]),{value:n}))));return f.forEach((n=>n(l))),l},pipe:function(n,t=_){return d[n.id]={node:n,pipe:t},l.outputs.forEach(((t,e)=>t.connected.push({id:n.id,idx:e}))),n.inputs.forEach(((n,t)=>n.connected.push({id:l.id,idx:t}))),l.run(),n},connect:function(n,t,e){return d[t.id]={node:t,pipe:(...t)=>({[e]:t[n]})},l.outputs[n].connected.push({id:t.id,idx:e}),t.inputs[e].connected.push({id:l.id,idx:n}),l.run(),f.forEach((n=>n(l))),l},disconnect:function(n,t,e){const o=l.outputs[n].connected.findIndex((({id:n,idx:o})=>n===t.id&&o===e));return l.outputs[n].connected.splice(o,1),t.inputs[e].connected=[],l},subscribe:function(n){return f.push(n),f.length-1},unsubscribe:function(n){return!(n>f.length)&&(f.splice(n,1),!0)}};function g(n=r.map((n=>n.value))){const t=i(...n);return Object.assign(u,t.map(((n,t)=>__assign(__assign({},u[t]),{value:n})))),Object.values(d).forEach((({node:n,pipe:e})=>n.set(e(...t)))),f.forEach((n=>n(l))),l}const _=(...n)=>[...n];return l},Object.defineProperty(n,"__esModule",{value:!0}),n[Symbol.toStringTag]="Module"}));
