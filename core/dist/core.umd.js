var __assign=Object.assign;!function(n,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((n="undefined"!=typeof globalThis?globalThis:n||self).core={})}(this,(function(n){"use strict";var e,t=new Uint8Array(16);function o(){if(!e&&!(e="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return e(t)}var i=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function r(n){return"string"==typeof n&&i.test(n)}for(var s,a=[],u=0;u<256;++u)a.push((u+256).toString(16).substr(1));function p(n,e,t){var i=(n=n||{}).random||(n.rng||o)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=i[s];return e}return function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=(a[n[e+0]]+a[n[e+1]]+a[n[e+2]]+a[n[e+3]]+"-"+a[n[e+4]]+a[n[e+5]]+"-"+a[n[e+6]]+a[n[e+7]]+"-"+a[n[e+8]]+a[n[e+9]]+"-"+a[n[e+10]]+a[n[e+11]]+a[n[e+12]]+a[n[e+13]]+a[n[e+14]]+a[n[e+15]]).toLowerCase();if(!r(t))throw TypeError("Stringified UUID is invalid");return t}(i)}n.DT=void 0,(s=n.DT||(n.DT={})).any="any",s.str="string",s.num="number",s.obj="object",s.vec2="vec2",s.vec3="vec3",s.rgb="rgb",s.hsl="hsl",s.vec4="vec4",s.rgba="rgba",s.mat2="mat2",s.mat3="mat3",s.mat4="mat4";const c=n=>[...Array(n).keys()];n.create=function(e,t,o){const i=function(e,t){var o;const i=(null==t?void 0:t.inputTypes)||(null==(o=c(e.length))?void 0:o.map((e=>n.DT.any))),r=(null==t?void 0:t.outputTypes)||[];return(...n)=>{var t,o;let s=e(...n)||[];return s.__inputs__=null==(t=c(e.length))?void 0:t.map(((e,t)=>i[t]||typeof n[t])),s.__outputs__=null==(o=c(s.length))?void 0:o.map(((n,e)=>r[e]||typeof s[e])),s}}(e,{inputTypes:(o=__assign({in:[],out:[]},o||{})).in.map((n=>n.type)),outputTypes:o.out.map((n=>n.type))}),r=i(...t);let s=t.map(((n,e)=>__assign(__assign({},o.in[e]),{value:n,connected:[]}))),a=r.map(((n,e)=>__assign(__assign({},o.out[e]),{value:n,connected:[]}))),u=new Proxy(s,(n=>({set:(e,t,o)=>{try{e[t]=o}catch(i){return!1}finally{return n(o),!0}}}))((()=>g())));const d={},f=[],l={id:p(),inputs:s,outputs:a,run:g,set:function(n){Array.isArray(n)?Object.assign(u,n.map(((n,e)=>__assign(__assign({},s[e]),{value:n})))):"object"==typeof n?Object.entries(n).forEach((([n,e])=>{let t=isNaN(parseInt(n))?(n=>s.findIndex((e=>e.name===n)))(n):n;if(!(t>-1))throw new Error(`Unrecognized input name '${n}'.`);u[t]=__assign(__assign({},s[t]),{value:e})})):"function"==typeof n?Object.assign(u,n(...s.map((n=>n.value))).map(((n,e)=>__assign(__assign({},s[e]),{value:n})))):Object.assign(u,[n].map(((n,e)=>__assign(__assign({},s[e]),{value:n}))));return f.forEach((n=>n(l))),l},pipe:function(n,e=_){return d[n.id]={node:n,pipe:e},l.outputs.forEach(((e,t)=>e.connected.push({id:n.id,idx:t}))),n.inputs.forEach(((n,e)=>n.connected.push({id:l.id,idx:e}))),l.run(),n},connect:function(n,e,t){return d[e.id]={node:e,pipe:(...e)=>({[t]:e[n]})},l.outputs[n].connected.push({id:e.id,idx:t}),e.inputs[t].connected.push({id:l.id,idx:n}),l.run(),f.forEach((n=>n(l))),l},subscribe:function(n){return f.push(n),f.length-1},unsubscribe:function(n){return!(n>f.length)&&(f.splice(n,1),!0)}};function g(n=s.map((n=>n.value))){const e=i(...n);return Object.assign(a,e.map(((n,e)=>__assign(__assign({},a[e]),{value:n})))),Object.values(d).forEach((({node:n,pipe:t})=>n.set(t(...e)))),f.forEach((n=>n(l))),l}const _=(...n)=>[...n];return l},Object.defineProperty(n,"__esModule",{value:!0}),n[Symbol.toStringTag]="Module"}));
